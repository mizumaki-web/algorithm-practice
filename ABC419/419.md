# A
- mapをもちいる
```
import java.util.*;

public class A419 {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String A = sc.next();

        Map<String, String> dict = Map.of(
            "red", "SSS",
            "blue", "FFF",
            "green", "MMM"
        );

        System.out.println(dict.getOrDefault(A, "Unknown"));
    }
}
```

# B
- データ構造
リストに追加して都度 sort、先頭を remove は、毎回 O(n log n) ＋ O(n)（先頭削除で詰め替え発生）。優先度付きキュー（PriorityQueue）なら、追加・取り出しどちらも平均 O(log n) で、実装も直感的。
- 入力処理
sc.nextLine() は今回ほぼ不要。nextInt() で統一すれば改行の扱いに悩まない。
　また、Integer[] query は保持せず、その場で処理してしまうのがシンプル。
- プリミティブ型での分岐
Integer.equals(1) ではなく、int t = sc.nextInt(); if (t == 1) ... の方が自然でオートボクシングの無駄もない。
- 出力のまとめ
逐次 System.out.println でも通るけれど、StringBuilder に貯めて最後に一度出力すると I/O が安定する。
```
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int Q = sc.nextInt();

        PriorityQueue<Integer> pq = new PriorityQueue<>(); // 最小ヒープ
        StringBuilder out = new StringBuilder();

        for (int i = 0; i < Q; i++) {
            int t = sc.nextInt();
            if (t == 1) {
                int x = sc.nextInt();
                pq.add(x);
            } else { // t == 2（空でないことは保証）
                out.append(pq.poll()).append('\n');
            }
        }
        System.out.print(out.toString());
    }
}
```
別解（制約特化のカウント配列）
x が 1〜100 に限られているから、頻度配列を使っても書ける。cur を最小の在庫位置に保っておけば、取り出しは最大 100 ステップで見つかる。実装は短いけれど、一般化しづらいから私は PriorityQueue 推しよ。
```
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int Q = sc.nextInt();
        int[] cnt = new int[101]; // 1..100
        int cur = 1;
        StringBuilder out = new StringBuilder();

        for (int i = 0; i < Q; i++) {
            int t = sc.nextInt();
            if (t == 1) {
                int x = sc.nextInt();
                cnt[x]++;
                if (x < cur) cur = x;
            } else {
                while (cnt[cur] == 0) cur++;
                out.append(cur).append('\n');
                cnt[cur]--;
                while (cur <= 100 && cnt[cur] == 0) cur++;
                if (cur > 100) cur = 100; // ダミー保守
            }
        }
        System.out.print(out.toString());
    }
}
```
