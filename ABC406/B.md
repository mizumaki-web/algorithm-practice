```
#include <iostream>
#include <climits>
#include <math.h>
using namespace std;

int main(){
  long long N, K;
  cin >> N >> K;
  long long ans = 1;
  long long b = (long long)pow(10,K);

  for(int i = 0; i < N; i++){
    long long a;
    cin  >> a;
    if((ans > LLONG_MAX / a ) || ans * a  >= b) ans = 1;
    else ans *= a;
  }
  
  cout << ans << endl;
  
  return 0;
}
```

問題リンク：https://atcoder.jp/contests/abc406/tasks/abc406_b

提出リンク：https://atcoder.jp/contests/abc406/submissions/65930967

## 問題文

高橋君は電卓を持っています。電卓には最初 1 が表示されています。
高橋君は電卓に対して N 回操作を行います。
i 回目 (1≤i≤N) の操作では、その時点で画面に表示されている数に正の整数 A i  をかけます。
しかし、電卓には K 桁までしか表示できないため、計算結果が (K+1) 桁以上になる場合、代わりに 
1 が画面に表示されます。 そうでない場合は正しく計算結果が表示されます。
N 回の操作の後に電卓に表示されている数を求めてください。

## 制約
- 1 ≤ N ≤ 100
- 1 ≤ K ≤ 18
- 1 ≤ Ai <10^K 
- 入力はすべて整数


## 実行例

入力:
5 2
7 13 3 2 5

出力: 10

今回電卓は 2 桁まで表示することができ、最初 1 が表示されています。これに対して、次のように高橋君は操作を行います。
- 1 回目の操作で、7 をかけます。1×7=7 であり、電卓には7 が表示されます。
- 2 回目の操作で、13 をかけます。7×13=91 であり、電卓には 91 が表示されます。
- 3 回目の操作で、3 をかけます。91×3=273 であり、3 桁になってしまうため、電卓には 1 が表示されます。
- 4 回目の操作で、2 をかけます。1×2=2 であり、電卓には 2 が表示されます。
- 5 回目の操作で、5 をかけます。2×5=10 であり、電卓には 10 が表示されます。

## アルゴリズム・考え方：
- 10^18 と大きい数字は long long 型にします。
- 最大数は K 桁までなので、最大数 b は 10^K - 1 と表せます
- ans (現在の表示) * a (入力) が b (最大数) より大きいと ans を 1 に、小さいと ans を ans * a とします
- しかし ans * a が long long 型よりも大きいことを考慮して LLONG_MAX(long long の最大値) ( > b) を 入力 a で割ったとき 画面表示 ans より小さければ ans = 1 にします(ans * a>LLONG_MAX ならば ans * a>bなので)
 
